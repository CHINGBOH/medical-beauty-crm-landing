import { pgTable, check, serial, varchar, text, integer, timestamp, numeric, unique, index, foreignKey, boolean, jsonb } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const knowledgeBase = pgTable("knowledge_base", {
	id: serial().primaryKey().notNull(),
	type: varchar({ length: 20 }).default('customer').notNull(),
	title: varchar({ length: 255 }).notNull(),
	content: text().notNull(),
	category: varchar({ length: 100 }).notNull(),
	tags: text(),
	embedding: text(),
	viewCount: integer("view_count").default(0).notNull(),
	usedCount: integer("used_count").default(0).notNull(),
	isActive: integer("is_active").default(1).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
	embeddingJson: text("embedding_json"),
	qualityScore: numeric("quality_score", { precision: 3, scale:  2 }).default('0.00'),
	estimatedReadTime: integer("estimated_read_time").default(5),
	version: varchar({ length: 20 }).default('1.0'),
	lastReviewedAt: timestamp("last_reviewed_at", { mode: 'string' }),
	parentId: integer("parent_id"),
	level: integer().default(1).notNull(),
	path: text(),
	order: integer().default(0).notNull(),
	module: varchar({ length: 50 }).default('skin_care').notNull(),
	subCategory: varchar("sub_category", { length: 100 }),
	summary: text(),
	positiveEvidence: text("positive_evidence"),
	negativeEvidence: text("negative_evidence"),
	neutralAnalysis: text("neutral_analysis"),
	practicalGuide: text("practical_guide"),
	caseStudies: text("case_studies"),
	expertOpinions: text("expert_opinions"),
	images: text(),
	videos: text(),
	audio: text(),
	sources: text(),
	credibility: integer().default(5).notNull(),
	difficulty: varchar({ length: 20 }).default('beginner'),
	likeCount: integer("like_count").default(0).notNull(),
	shareCount: integer("share_count").default(0).notNull(),
}, (table) => [
	check("knowledge_base_id_not_null", sql`NOT NULL id`),
	check("knowledge_base_type_not_null", sql`NOT NULL type`),
	check("knowledge_base_title_not_null", sql`NOT NULL title`),
	check("knowledge_base_content_not_null", sql`NOT NULL content`),
	check("knowledge_base_category_not_null", sql`NOT NULL category`),
	check("knowledge_base_view_count_not_null", sql`NOT NULL view_count`),
	check("knowledge_base_used_count_not_null", sql`NOT NULL used_count`),
	check("knowledge_base_is_active_not_null", sql`NOT NULL is_active`),
	check("knowledge_base_created_at_not_null", sql`NOT NULL created_at`),
	check("knowledge_base_updated_at_not_null", sql`NOT NULL updated_at`),
	check("knowledge_base_level_not_null", sql`NOT NULL level`),
	check("knowledge_base_order_not_null", sql`NOT NULL "order"`),
	check("knowledge_base_module_not_null", sql`NOT NULL module`),
	check("knowledge_base_credibility_not_null", sql`NOT NULL credibility`),
	check("knowledge_base_like_count_not_null", sql`NOT NULL like_count`),
	check("knowledge_base_share_count_not_null", sql`NOT NULL share_count`),
]);

export const triggerExecutions = pgTable("trigger_executions", {
	id: serial().primaryKey().notNull(),
	triggerId: integer("trigger_id").notNull(),
	leadId: integer("lead_id"),
	executedAt: timestamp("executed_at", { mode: 'string' }).defaultNow().notNull(),
	status: varchar({ length: 20 }).notNull(),
	result: text(),
	errorMessage: text("error_message"),
}, (table) => [
	check("trigger_executions_id_not_null", sql`NOT NULL id`),
	check("trigger_executions_trigger_id_not_null", sql`NOT NULL trigger_id`),
	check("trigger_executions_executed_at_not_null", sql`NOT NULL executed_at`),
	check("trigger_executions_status_not_null", sql`NOT NULL status`),
]);

export const weworkContactWay = pgTable("wework_contact_way", {
	id: serial().primaryKey().notNull(),
	configId: varchar("config_id", { length: 100 }).notNull(),
	type: varchar({ length: 10 }).default('single').notNull(),
	scene: varchar({ length: 10 }).default('1').notNull(),
	qrCode: text("qr_code"),
	remark: varchar({ length: 255 }),
	skipVerify: integer("skip_verify").default(1).notNull(),
	state: varchar({ length: 100 }),
	userIds: text("user_ids"),
	isActive: integer("is_active").default(1).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("wework_contact_way_config_id_key").on(table.configId),
	check("wework_contact_way_id_not_null", sql`NOT NULL id`),
	check("wework_contact_way_config_id_not_null", sql`NOT NULL config_id`),
	check("wework_contact_way_type_not_null", sql`NOT NULL type`),
	check("wework_contact_way_scene_not_null", sql`NOT NULL scene`),
	check("wework_contact_way_skip_verify_not_null", sql`NOT NULL skip_verify`),
	check("wework_contact_way_is_active_not_null", sql`NOT NULL is_active`),
	check("wework_contact_way_created_at_not_null", sql`NOT NULL created_at`),
	check("wework_contact_way_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const weworkMessages = pgTable("wework_messages", {
	id: serial().primaryKey().notNull(),
	externalUserId: varchar("external_user_id", { length: 100 }).notNull(),
	sendUserId: varchar("send_user_id", { length: 100 }).notNull(),
	msgType: varchar("msg_type", { length: 20 }).notNull(),
	content: text().notNull(),
	status: varchar({ length: 20 }).default('pending').notNull(),
	errorMsg: text("error_msg"),
	sentAt: timestamp("sent_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("wework_messages_id_not_null", sql`NOT NULL id`),
	check("wework_messages_external_user_id_not_null", sql`NOT NULL external_user_id`),
	check("wework_messages_send_user_id_not_null", sql`NOT NULL send_user_id`),
	check("wework_messages_msg_type_not_null", sql`NOT NULL msg_type`),
	check("wework_messages_content_not_null", sql`NOT NULL content`),
	check("wework_messages_status_not_null", sql`NOT NULL status`),
	check("wework_messages_created_at_not_null", sql`NOT NULL created_at`),
]);

export const systemConfig = pgTable("system_config", {
	id: serial().primaryKey().notNull(),
	configKey: varchar("config_key", { length: 100 }).notNull(),
	configValue: text("config_value"),
	description: text(),
	isActive: integer("is_active").default(1).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("system_config_config_key_key").on(table.configKey),
	check("system_config_id_not_null", sql`NOT NULL id`),
	check("system_config_config_key_not_null", sql`NOT NULL config_key`),
	check("system_config_is_active_not_null", sql`NOT NULL is_active`),
	check("system_config_created_at_not_null", sql`NOT NULL created_at`),
	check("system_config_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const xiaohongshuPosts = pgTable("xiaohongshu_posts", {
	id: serial().primaryKey().notNull(),
	title: varchar({ length: 255 }).notNull(),
	content: text().notNull(),
	images: text(),
	tags: text(),
	contentType: varchar("content_type", { length: 50 }).notNull(),
	project: varchar({ length: 100 }),
	status: varchar({ length: 20 }).default('draft').notNull(),
	publishedAt: timestamp("published_at", { mode: 'string' }),
	scheduledAt: timestamp("scheduled_at", { mode: 'string' }),
	viewCount: integer("view_count").default(0).notNull(),
	likeCount: integer("like_count").default(0).notNull(),
	commentCount: integer("comment_count").default(0).notNull(),
	shareCount: integer("share_count").default(0).notNull(),
	collectCount: integer("collect_count").default(0).notNull(),
	lastSyncedAt: timestamp("last_synced_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("xiaohongshu_posts_id_not_null", sql`NOT NULL id`),
	check("xiaohongshu_posts_title_not_null", sql`NOT NULL title`),
	check("xiaohongshu_posts_content_not_null", sql`NOT NULL content`),
	check("xiaohongshu_posts_content_type_not_null", sql`NOT NULL content_type`),
	check("xiaohongshu_posts_status_not_null", sql`NOT NULL status`),
	check("xiaohongshu_posts_view_count_not_null", sql`NOT NULL view_count`),
	check("xiaohongshu_posts_like_count_not_null", sql`NOT NULL like_count`),
	check("xiaohongshu_posts_comment_count_not_null", sql`NOT NULL comment_count`),
	check("xiaohongshu_posts_share_count_not_null", sql`NOT NULL share_count`),
	check("xiaohongshu_posts_collect_count_not_null", sql`NOT NULL collect_count`),
	check("xiaohongshu_posts_created_at_not_null", sql`NOT NULL created_at`),
	check("xiaohongshu_posts_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const weworkCustomers = pgTable("wework_customers", {
	id: serial().primaryKey().notNull(),
	externalUserId: varchar("external_user_id", { length: 100 }).notNull(),
	name: varchar({ length: 100 }),
	avatar: text(),
	type: varchar({ length: 10 }).default('1').notNull(),
	gender: varchar({ length: 10 }).default('0').notNull(),
	unionId: varchar("union_id", { length: 100 }),
	position: varchar({ length: 100 }),
	corpName: varchar("corp_name", { length: 200 }),
	corpFullName: varchar("corp_full_name", { length: 200 }),
	externalProfile: text("external_profile"),
	followUserId: varchar("follow_user_id", { length: 100 }),
	remark: varchar({ length: 255 }),
	description: text(),
	createTime: timestamp("create_time", { mode: 'string' }),
	tags: text(),
	state: varchar({ length: 100 }),
	conversationId: integer("conversation_id"),
	leadId: varchar("lead_id", { length: 100 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("wework_customers_external_user_id_key").on(table.externalUserId),
	check("wework_customers_id_not_null", sql`NOT NULL id`),
	check("wework_customers_external_user_id_not_null", sql`NOT NULL external_user_id`),
	check("wework_customers_type_not_null", sql`NOT NULL type`),
	check("wework_customers_gender_not_null", sql`NOT NULL gender`),
	check("wework_customers_created_at_not_null", sql`NOT NULL created_at`),
	check("wework_customers_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const conversations = pgTable("conversations", {
	id: serial().primaryKey().notNull(),
	sessionId: varchar("session_id", { length: 64 }).notNull(),
	visitorName: varchar("visitor_name", { length: 100 }),
	visitorPhone: varchar("visitor_phone", { length: 20 }),
	visitorWechat: varchar("visitor_wechat", { length: 100 }),
	source: varchar({ length: 50 }).default('web').notNull(),
	status: varchar({ length: 20 }).default('active').notNull(),
	leadId: varchar("lead_id", { length: 100 }),
	psychologyType: varchar("psychology_type", { length: 20 }),
	psychologyTags: text("psychology_tags"),
	budgetLevel: varchar("budget_level", { length: 20 }),
	customerTier: varchar("customer_tier", { length: 10 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("conversations_session_id_key").on(table.sessionId),
	check("conversations_id_not_null", sql`NOT NULL id`),
	check("conversations_session_id_not_null", sql`NOT NULL session_id`),
	check("conversations_source_not_null", sql`NOT NULL source`),
	check("conversations_status_not_null", sql`NOT NULL status`),
	check("conversations_created_at_not_null", sql`NOT NULL created_at`),
	check("conversations_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const leads = pgTable("leads", {
	id: serial().primaryKey().notNull(),
	airtableId: varchar("airtable_id", { length: 100 }),
	name: varchar({ length: 100 }).notNull(),
	phone: varchar({ length: 20 }).notNull(),
	wechat: varchar({ length: 100 }),
	age: integer(),
	interestedServices: text("interested_services"),
	budget: varchar({ length: 50 }),
	budgetLevel: varchar("budget_level", { length: 20 }),
	message: text(),
	source: varchar({ length: 50 }).notNull(),
	sourceContent: varchar("source_content", { length: 255 }),
	status: varchar({ length: 50 }).default('new').notNull(),
	psychologyType: varchar("psychology_type", { length: 50 }),
	psychologyTags: text("psychology_tags"),
	customerTier: varchar("customer_tier", { length: 10 }),
	notes: text(),
	followUpDate: timestamp("follow_up_date", { mode: 'string' }),
	conversationId: integer("conversation_id"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
	syncedAt: timestamp("synced_at", { mode: 'string' }),
}, (table) => [
	unique("leads_airtable_id_key").on(table.airtableId),
	check("leads_id_not_null", sql`NOT NULL id`),
	check("leads_name_not_null", sql`NOT NULL name`),
	check("leads_phone_not_null", sql`NOT NULL phone`),
	check("leads_source_not_null", sql`NOT NULL source`),
	check("leads_status_not_null", sql`NOT NULL status`),
	check("leads_created_at_not_null", sql`NOT NULL created_at`),
	check("leads_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const triggers = pgTable("triggers", {
	id: serial().primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	description: text(),
	type: varchar({ length: 20 }).notNull(),
	timeConfig: text("time_config"),
	behaviorConfig: text("behavior_config"),
	weatherConfig: text("weather_config"),
	action: varchar({ length: 30 }).notNull(),
	actionConfig: text("action_config"),
	targetFilter: text("target_filter"),
	isActive: integer("is_active").default(1).notNull(),
	executionCount: integer("execution_count").default(0).notNull(),
	lastExecutedAt: timestamp("last_executed_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("triggers_id_not_null", sql`NOT NULL id`),
	check("triggers_name_not_null", sql`NOT NULL name`),
	check("triggers_type_not_null", sql`NOT NULL type`),
	check("triggers_action_not_null", sql`NOT NULL action`),
	check("triggers_is_active_not_null", sql`NOT NULL is_active`),
	check("triggers_execution_count_not_null", sql`NOT NULL execution_count`),
	check("triggers_created_at_not_null", sql`NOT NULL created_at`),
	check("triggers_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const messages = pgTable("messages", {
	id: serial().primaryKey().notNull(),
	conversationId: integer("conversation_id").notNull(),
	role: varchar({ length: 20 }).notNull(),
	content: text().notNull(),
	knowledgeUsed: text("knowledge_used"),
	extractedInfo: text("extracted_info"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("messages_id_not_null", sql`NOT NULL id`),
	check("messages_conversation_id_not_null", sql`NOT NULL conversation_id`),
	check("messages_role_not_null", sql`NOT NULL role`),
	check("messages_content_not_null", sql`NOT NULL content`),
	check("messages_created_at_not_null", sql`NOT NULL created_at`),
]);

export const users = pgTable("users", {
	id: serial().primaryKey().notNull(),
	openId: varchar({ length: 64 }).notNull(),
	name: text(),
	email: varchar({ length: 320 }),
	loginMethod: varchar({ length: 64 }),
	role: varchar({ length: 20 }).default('user').notNull(),
	createdAt: timestamp({ mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp({ mode: 'string' }).defaultNow().notNull(),
	lastSignedIn: timestamp({ mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("users_openId_key").on(table.openId),
	check("users_id_not_null", sql`NOT NULL id`),
	check("users_openId_not_null", sql`NOT NULL "openId"`),
	check("users_role_not_null", sql`NOT NULL role`),
	check("users_createdAt_not_null", sql`NOT NULL "createdAt"`),
	check("users_updatedAt_not_null", sql`NOT NULL "updatedAt"`),
	check("users_lastSignedIn_not_null", sql`NOT NULL "lastSignedIn"`),
]);

export const weworkConfig = pgTable("wework_config", {
	id: serial().primaryKey().notNull(),
	corpId: varchar("corp_id", { length: 100 }),
	corpSecret: varchar("corp_secret", { length: 200 }),
	agentId: integer("agent_id"),
	token: varchar({ length: 100 }),
	encodingAesKey: varchar("encoding_aes_key", { length: 200 }),
	accessToken: text("access_token"),
	tokenExpiresAt: timestamp("token_expires_at", { mode: 'string' }),
	isActive: integer("is_active").default(1).notNull(),
	isMockMode: integer("is_mock_mode").default(1).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("wework_config_id_not_null", sql`NOT NULL id`),
	check("wework_config_is_active_not_null", sql`NOT NULL is_active`),
	check("wework_config_is_mock_mode_not_null", sql`NOT NULL is_mock_mode`),
	check("wework_config_created_at_not_null", sql`NOT NULL created_at`),
	check("wework_config_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const xiaohongshuComments = pgTable("xiaohongshu_comments", {
	id: serial().primaryKey().notNull(),
	postId: integer("post_id").notNull(),
	authorName: varchar("author_name", { length: 100 }).notNull(),
	authorAvatar: varchar("author_avatar", { length: 500 }),
	content: text().notNull(),
	replyContent: text("reply_content"),
	replyStatus: varchar("reply_status", { length: 20 }).default('pending').notNull(),
	sentiment: varchar({ length: 20 }),
	isFiltered: integer("is_filtered").default(0).notNull(),
	commentedAt: timestamp("commented_at", { mode: 'string' }).notNull(),
	repliedAt: timestamp("replied_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("xiaohongshu_comments_id_not_null", sql`NOT NULL id`),
	check("xiaohongshu_comments_post_id_not_null", sql`NOT NULL post_id`),
	check("xiaohongshu_comments_author_name_not_null", sql`NOT NULL author_name`),
	check("xiaohongshu_comments_content_not_null", sql`NOT NULL content`),
	check("xiaohongshu_comments_reply_status_not_null", sql`NOT NULL reply_status`),
	check("xiaohongshu_comments_is_filtered_not_null", sql`NOT NULL is_filtered`),
	check("xiaohongshu_comments_commented_at_not_null", sql`NOT NULL commented_at`),
	check("xiaohongshu_comments_created_at_not_null", sql`NOT NULL created_at`),
]);

export const userLearningProgress = pgTable("user_learning_progress", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	contentId: integer("content_id").notNull(),
	status: varchar({ length: 20 }).default('started').notNull(),
	timeSpent: integer("time_spent").default(0),
	rating: integer(),
	feedback: text(),
	startedAt: timestamp("started_at", { mode: 'string' }).defaultNow(),
	completedAt: timestamp("completed_at", { mode: 'string' }),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_user_learning_progress_content_id").using("btree", table.contentId.asc().nullsLast().op("int4_ops")),
	index("idx_user_learning_progress_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_user_learning_progress_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "user_learning_progress_user_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contentId],
			foreignColumns: [knowledgeBase.id],
			name: "user_learning_progress_content_id_fkey"
		}).onDelete("cascade"),
	unique("user_learning_progress_user_id_content_id_key").on(table.userId, table.contentId),
	check("user_learning_progress_status_check", sql`(status)::text = ANY ((ARRAY['started'::character varying, 'in_progress'::character varying, 'completed'::character varying, 'skipped'::character varying])::text[])`),
	check("user_learning_progress_rating_check", sql`(rating >= 1) AND (rating <= 5)`),
	check("user_learning_progress_id_not_null", sql`NOT NULL id`),
	check("user_learning_progress_user_id_not_null", sql`NOT NULL user_id`),
	check("user_learning_progress_content_id_not_null", sql`NOT NULL content_id`),
	check("user_learning_progress_status_not_null", sql`NOT NULL status`),
]);

export const expertReviews = pgTable("expert_reviews", {
	id: serial().primaryKey().notNull(),
	contentId: integer("content_id").notNull(),
	expertId: varchar("expert_id", { length: 100 }).notNull(),
	expertName: varchar("expert_name", { length: 200 }).notNull(),
	credentials: text(),
	reviewDate: timestamp("review_date", { mode: 'string' }).defaultNow(),
	overallRating: integer("overall_rating").notNull(),
	comments: text(),
	recommendations: text().array(),
	approved: boolean().default(false),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_expert_reviews_approved").using("btree", table.approved.asc().nullsLast().op("bool_ops")),
	index("idx_expert_reviews_content_id").using("btree", table.contentId.asc().nullsLast().op("int4_ops")),
	index("idx_expert_reviews_expert_id").using("btree", table.expertId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.contentId],
			foreignColumns: [knowledgeBase.id],
			name: "expert_reviews_content_id_fkey"
		}).onDelete("cascade"),
	check("expert_reviews_overall_rating_check", sql`(overall_rating >= 1) AND (overall_rating <= 10)`),
	check("expert_reviews_id_not_null", sql`NOT NULL id`),
	check("expert_reviews_content_id_not_null", sql`NOT NULL content_id`),
	check("expert_reviews_expert_id_not_null", sql`NOT NULL expert_id`),
	check("expert_reviews_expert_name_not_null", sql`NOT NULL expert_name`),
	check("expert_reviews_overall_rating_not_null", sql`NOT NULL overall_rating`),
]);

export const contentQualityMetrics = pgTable("content_quality_metrics", {
	id: serial().primaryKey().notNull(),
	contentId: integer("content_id").notNull(),
	completenessScore: numeric("completeness_score", { precision: 3, scale:  2 }).default('0.00'),
	reliabilityScore: numeric("reliability_score", { precision: 3, scale:  2 }).default('0.00'),
	credibilityScore: numeric("credibility_score", { precision: 3, scale:  2 }).default('0.00'),
	richnessScore: numeric("richness_score", { precision: 3, scale:  2 }).default('0.00'),
	engagementScore: numeric("engagement_score", { precision: 3, scale:  2 }).default('0.00'),
	overallScore: numeric("overall_score", { precision: 3, scale:  2 }).default('0.00'),
	issues: jsonb().default([]),
	recommendations: jsonb().default([]),
	status: varchar({ length: 20 }).default('pending'),
	reviewedBy: varchar("reviewed_by", { length: 100 }),
	reviewedAt: timestamp("reviewed_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_content_quality_metrics_content_id").using("btree", table.contentId.asc().nullsLast().op("int4_ops")),
	index("idx_content_quality_metrics_overall_score").using("btree", table.overallScore.asc().nullsLast().op("numeric_ops")),
	index("idx_content_quality_metrics_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.contentId],
			foreignColumns: [knowledgeBase.id],
			name: "content_quality_metrics_content_id_fkey"
		}).onDelete("cascade"),
	unique("content_quality_metrics_content_id_key").on(table.contentId),
	check("content_quality_metrics_completeness_score_check", sql`(completeness_score >= (0)::numeric) AND (completeness_score <= (1)::numeric)`),
	check("content_quality_metrics_reliability_score_check", sql`(reliability_score >= (0)::numeric) AND (reliability_score <= (1)::numeric)`),
	check("content_quality_metrics_credibility_score_check", sql`(credibility_score >= (0)::numeric) AND (credibility_score <= (1)::numeric)`),
	check("content_quality_metrics_richness_score_check", sql`(richness_score >= (0)::numeric) AND (richness_score <= (1)::numeric)`),
	check("content_quality_metrics_engagement_score_check", sql`(engagement_score >= (0)::numeric) AND (engagement_score <= (1)::numeric)`),
	check("content_quality_metrics_overall_score_check", sql`(overall_score >= (0)::numeric) AND (overall_score <= (1)::numeric)`),
	check("content_quality_metrics_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'needs_revision'::character varying])::text[])`),
	check("content_quality_metrics_id_not_null", sql`NOT NULL id`),
	check("content_quality_metrics_content_id_not_null", sql`NOT NULL content_id`),
]);

export const userLearningPreferences = pgTable("user_learning_preferences", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	preferredDifficulty: varchar("preferred_difficulty", { length: 20 }).default('beginner'),
	preferredContentTypes: text("preferred_content_types").array(),
	learningGoals: text("learning_goals").array(),
	timePreference: varchar("time_preference", { length: 20 }).default('medium'),
	interests: text().array(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_user_learning_preferences_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "user_learning_preferences_user_id_fkey"
		}).onDelete("cascade"),
	unique("user_learning_preferences_user_id_key").on(table.userId),
	check("user_learning_preferences_preferred_difficulty_check", sql`(preferred_difficulty)::text = ANY ((ARRAY['beginner'::character varying, 'intermediate'::character varying, 'advanced'::character varying])::text[])`),
	check("user_learning_preferences_time_preference_check", sql`(time_preference)::text = ANY ((ARRAY['short'::character varying, 'medium'::character varying, 'long'::character varying])::text[])`),
	check("user_learning_preferences_id_not_null", sql`NOT NULL id`),
	check("user_learning_preferences_user_id_not_null", sql`NOT NULL user_id`),
]);

export const learningAnalytics = pgTable("learning_analytics", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	eventType: varchar("event_type", { length: 50 }).notNull(),
	contentId: integer("content_id"),
	sessionId: varchar("session_id", { length: 100 }),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_learning_analytics_content_id").using("btree", table.contentId.asc().nullsLast().op("int4_ops")),
	index("idx_learning_analytics_created_at").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("idx_learning_analytics_event_type").using("btree", table.eventType.asc().nullsLast().op("text_ops")),
	index("idx_learning_analytics_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "learning_analytics_user_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contentId],
			foreignColumns: [knowledgeBase.id],
			name: "learning_analytics_content_id_fkey"
		}).onDelete("set null"),
	check("learning_analytics_id_not_null", sql`NOT NULL id`),
	check("learning_analytics_user_id_not_null", sql`NOT NULL user_id`),
	check("learning_analytics_event_type_not_null", sql`NOT NULL event_type`),
]);

export const websiteContent = pgTable("website_content", {
  id: serial("id").primaryKey(),
  pageKey: varchar("page_key", { length: 100 }).notNull(),
  sectionKey: varchar("section_key", { length: 100 }),
  contentType: varchar("content_type", { length: 50 }).notNull(),
  title: varchar("title", { length: 255 }),
  content: text("content").notNull(),
  imageUrl: text("image_url"),
  linkUrl: text("link_url"),
  linkText: varchar("link_text", { length: 255 }),
  sortOrder: integer("sort_order").default(0).notNull(),
  isActive: integer("is_active").default(1).notNull(),
  metadata: text("metadata"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().$onUpdateFn(() => new Date()).notNull(),
});

export type WebsiteContent = typeof websiteContent.$inferSelect;
export type InsertWebsiteContent = typeof websiteContent.$inferInsert;
